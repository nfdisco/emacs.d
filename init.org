#+TITLE: GNU Emacs configuration

* Overview
Personal GNU Emacs configuration file.

Type ~M-x org-babel-tangle~ in this buffer to generate ~init.el~.

Non-built-in packages that are set up here:
- Solarized color theme
- Org-mode
- PO-mode
- AUCTeX
- ESS
- SLiME

* Configuration
:PROPERTIES:
:header-args:emacs-lisp: :tangle yes
:END:

** Preamble

#+BEGIN_SRC emacs-lisp
;; init.el -- configuration file for GNU Emacs
;;
;; Automatically generated, do not edit.

;; automatically added by package.el
;; (package-initialize)
#+END_SRC

** Global variables and constants

#+BEGIN_SRC emacs-lisp
(defconst windows-system (eq system-type 'windows-nt)
  "Non-nil if Emacs is running on a Microsoft Windows operating system.")
#+END_SRC

** Auxiliary files and library locations

Look for Lisp packages in ~$XDG_DATA_HOME/emacs/site-lisp~ (on Windows:
~%appdata%/emacs/site-lisp~) and in the ~lisp/~ subdirectory under the
user's Emacs directory.

#+BEGIN_SRC emacs-lisp
(let ((data-dir
       (if windows-system
           (getenv "appdata")
         (or (getenv "XDG_DATA_HOME")
             (expand-file-name "~/.local/share")))))
  (if (or (not (stringp data-dir))
          (string= data-dir ""))
      (message "Could not determine location of user's data directory")
    (add-to-list 'load-path
                 (concat (file-name-as-directory data-dir)
                         (file-name-as-directory "emacs")
                         "site-lisp"))))

(add-to-list 'load-path (expand-file-name "lisp" user-emacs-directory))
#+END_SRC

Prevent Emacs from loading obselete bytecode files (although this will
not prevent Emacs from loading an obsolete ~./init.elc~).

#+BEGIN_SRC emacs-lisp
(setq load-prefer-newer t)
#+END_SRC

** Customizations

Save customizations in a separate file.

#+BEGIN_SRC emacs-lisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
#+END_SRC

Load existing customizations.
#+BEGIN_SRC emacs-lisp
(load custom-file)
#+END_SRC

** Themes

Look for and save custom themes in the ~themes/~ subdirectory under the
user's Emacs directory.

#+BEGIN_SRC emacs-lisp
(setq custom-theme-directory (expand-file-name "themes" user-emacs-directory))
#+END_SRC

*** Solarized

Add the location of the theme's subdirectory to the search path.

#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path
             (expand-file-name "solarized" custom-theme-directory))
#+END_SRC

Override face difinitions with our own.  For the color names used by
this theme see: [[http://ethanschoonover.com/solarized]]

#+BEGIN_SRC emacs-lisp
(defvar solarized-custom-color-definitions nil
  "A list of face definitions, overriding the theme definitions.
  Each element is a list of the form

    (FACE SPEC)

  where FACE is a face name, and SPEC is a face specification that
  can include Solarized colors.")

(defun solarized-merge-custom-color-definitions (defs)
  "Update DEFS with new definitions from
  `solarized-custom-color-definitions' and return the result."
  (dolist (newdef solarized-custom-color-definitions defs)
    (setq defs (cons (apply 'create-face-spec newdef)
                     (assq-delete-all (car newdef) defs)))))

(advice-add 'solarized-color-definitions :filter-return
            'solarized-merge-custom-color-definitions)

(setq solarized-custom-color-definitions
      '((match   (:foreground base1                   :inverse-video t))
        (isearch (:foreground cyan   :background back :inverse-video t))
        ;; (whitespace-tab (:foreground base01 :background base02))
        (message-cited-text        (:inherit font-lock-comment-face))
        (message-header-cc         (:inherit font-lock-keyword-face))
        (message-header-name       (:inherit font-lock-keyword-face))
        (message-header-newsgroups (:inherit font-lock-keyword-face))
        (message-header-other      (:inherit font-lock-keyword-face))
        (message-header-subject    (:inherit font-lock-keyword-face))
        (message-header-to         (:inherit font-lock-keyword-face))
        (message-header-xheader    (:inherit font-lock-keyword-face))
        (gnus-header-content       (:inherit font-lock-keyword-face))
        (gnus-header-from          (:inherit font-lock-keyword-face))
        (gnus-header-name          (:inherit font-lock-keyword-face))
        (gnus-header-newsgroups    (:inherit font-lock-keyword-face))
        (gnus-header-subject       (:inherit font-lock-keyword-face))))
#+END_SRC

Allow bold fonts.

#+BEGIN_SRC emacs-lisp
(setq solarized-bold t)
#+END_SRC

Enable theme.

#+BEGIN_SRC emacs-lisp
(defun solarized-enable (&optional args)
  "Enable theme Solarized.  Arguments are ignored."
  (enable-theme 'solarized))

(add-hook 'after-make-frame-functions 'solarized-enable t)
(add-hook 'window-setup-hook 'solarized-enable t)

;; this should come at the very end
(load-theme 'solarized t t)
#+END_SRC

** Locale

Instead of the current locale, use the C locale (en_US) for date and
time formats.

#+BEGIN_SRC emacs-lisp
(setq system-time-locale "C")
#+END_SRC

** Auto-saving and backups

Enable auto-saving.

#+BEGIN_SRC emacs-lisp
(setq auto-save-default t)
(setq auto-save-interval 300)
(setq auto-save-timeout 60)
#+END_SRC

Disable automatic backups.

#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
#+END_SRC

** History

Remember minibuffer input across sessions.

#+BEGIN_SRC emacs-lisp
(savehist-mode 1)
(setq history-length 50000)
;; (setq history-delete-duplicates t)
#+END_SRC

Remember search strings across sessions.

#+BEGIN_SRC elisp
(let (vars '(search-ring regexp-search-ring))
  (if (boundp 'savehist-additional-variables)
      (dolist (var vars)
        (add-to-list savehist-additional-variables var))
    (setq savehist-additional-variables vars)))
#+END_SRC

Use ~C-p~, ~C-n~, ~M-p~ and ~M-n~ to navigate through minibuffer history while
in the minibuffer.

#+BEGIN_SRC emacs-lisp
(let ((map minibuffer-local-map))
  (define-key map [(meta ?p)] 'previous-complete-history-element)
  (define-key map [(meta ?n)] 'next-complete-history-element)
  (define-key map [(control ?p)] 'previous-history-element)
  (define-key map [(control ?n)] 'next-history-element))
#+END_SRC

Uncomment the following to save the kill ring across sessions.

#+BEGIN_SRC elisp
;; (let (vars '(kill-ring))
;;   (if (boundp 'savehist-additional-variables)
;;       (dolist (var vars)
;;         (add-to-list savehist-additional-variables var))
;;     (setq savehist-additional-variables vars)))
#+END_SRC

Jump to last known point position when opening a file.

#+BEGIN_SRC emacs-lisp
(require 'saveplace)
(save-place-mode)
(setq save-place-limit 5000)
#+END_SRC

*** DONE Recent files                                               :binding:

- [X] keep list of recently opened files
- [X] ~recentf-open-files~ > ~C-x g~

#+BEGIN_SRC emacs-lisp
(require 'recentf)
(recentf-mode)

(global-set-key [(control ?x) ?g] 'recentf-open-files)

(setq recentf-max-menu-items 10)
(setq recentf-max-saved-items recentf-max-menu-items)
(setq recentf-exclude
      '("\\.ido\\.last\\'"
        "\\.git/COMMIT_EDITMSG\\'"
        "/tmp/mutt-[^/]*\\'"
        "\\.mozilla/firefox/[^/]*\\.default/itsalltext/[^/]*\\.txt"))

;; do (recentf-cleanup) to clean up the recent files list manually
#+END_SRC


** DONE User interface
*** DONE Misc

- [X] disable startup screen
- [X] non-blinking cursor
- [X] limit size of mini-window
- [X] show column number in mode line

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
(blink-cursor-mode -1)
(setq max-mini-window-height 2)
(column-number-mode 1)
#+END_SRC

*** DONE Prompts

- [X] skip confirmation when creating new files/buffers
- [X] allow "y" and "n" in yes-or-no questions
- [X] enable visible bell

#+BEGIN_SRC emacs-lisp
(setq confirm-nonexistent-file-or-buffer nil)
(setq ido-create-new-buffer 'always)

(fset 'yes-or-no-p 'y-or-n-p)

(setq visible-bell t)
#+END_SRC

*** DONE Frame

- [X] set frame title
- [X] set default frame parameters and layout
- [X] show buffer boundaries in fringe
- [X] set background mode according to terminal type

#+BEGIN_SRC emacs-lisp
(setq frame-title-format "%b - Emacs")

(dolist (par '((height . 31)
               (width . 81)
               (vertical-scroll-bars . nil)
               (horizontal-scroll-bars . nil)
               (menu-bar-lines . 0)
               (tool-bar-lines . 0)))
  (push par default-frame-alist))

;; (tool-bar-mode -1)
;; (menu-bar-mode -1)
;; (scroll-bar-mode -1)

(setq-default
 indicate-buffer-boundaries
 '((top . left) (bottom . left) (up . right) (down . right)))

(setq background-mode '((graphic . light) (tty . light)))

(defvar background-mode nil
  "Background-mode property value for frames; a symbol specifying
  a MODE, either nil, `light' or `dark', or a list with elements

    (TERMINAL-TYPE . MODE)

  where TERMINAL-TYPE is one of `graphic' or `tty'.")

(defun set-background-mode (&optional frame)
  "Set FRAME's background-mode property depending on the value of
  `background-mode'.  If FRAME is nil, set the property on the
  current frame."
  (let* ((frame (selected-frame))
         (graphic-display (display-graphic-p))
         (terminal-type (if graphic-display 'graphic 'tty))
         (value (if (listp background-mode)
                    (cdr (assq terminal-type background-mode))
                  background-mode)))
    (set-frame-parameter frame 'background-mode value)
    (unless graphic-display
      (set-terminal-parameter frame 'background-mode value))))

(add-hook 'window-setup-hook 'set-background-mode)
(add-hook 'after-make-frame-functions 'set-background-mode)
#+END_SRC

*** DONE Fonts

- [X] set font
- [X] set underline style
- [X] enable file name shadow

#+BEGIN_SRC emacs-lisp
(push '(font . "Monospace-11") default-frame-alist)

(setq x-underline-at-descent-line t)

(file-name-shadow-mode 1)
#+END_SRC

** DONE Default whitespace style

- [X] only show tabs and trailing space by default

#+BEGIN_SRC emacs-lisp
(setq whitespace-style '(face trailing tabs tab-mark))
#+END_SRC

** DONE Scrolling

- [X] enable "smooth" scrolling
- [X] preserve screen position

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 1
      scroll-step 1
      scroll-conservatively 500)
(setq scroll-preserve-screen-position t)
#+END_SRC

** DONE Completion
*** DONE Completion lists                                           :binding:

- [X] ~previous-completion~ > ~p~
- [X] ~next-completion~ > ~n~
- [X] in ido mode: ~switch-to-completions~ > ~M-v~

#+BEGIN_SRC emacs-lisp
(let ((map completion-list-mode-map))
  (define-key map [?p] 'previous-completion)
  (define-key map [?n] 'next-completion))

(setq ido-completion-buffer "*Completions*")

(defun ido-completion-list-binding ()
  (define-key ido-common-completion-map [(meta ?v)]
    'switch-to-completions))
(add-hook 'ido-setup-hook 'ido-completion-list-binding)
#+END_SRC

*** DONE Minibuffer completion

- [X] ignore case when completing file/buffer names

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
(setq read-buffer-completion-ignore-case t)
#+END_SRC

ido mode:
- [X] enable ido mode / ido everywhere
- [X] conditionally set ido-enable-prefix when reading file and
  directory names
- [X] exclude dot files from suggestions
- [ ] enable flex matching
- [X] make TAB cycle through suggestions

#+BEGIN_SRC emacs-lisp
(require 'ido)
(ido-mode 1)
(ido-everywhere 1)

(setq ido-auto-merge-work-directories-length -1)
(setq ido-enable-dot-prefix nil)
(with-eval-after-load 'ido
  (add-to-list 'ido-ignore-files "\\`\\."))

(defvar ido-cur-item)			;prevent compiler warning

;; set `ido-enable-prefix' when completing file names
(defun ido-enable-prefix-if-file-dir ()
  (when (or (eq ido-cur-item 'file) (eq ido-cur-item 'dir))
    (setq ido-enable-prefix t)))

(add-hook 'ido-setup-hook 'ido-enable-prefix-if-file-dir)

(setq ido-report-no-match nil)
;; (setq ido-enable-flex-matching t)
(setq ido-cannot-complete-command 'ido-next-match) ; cycle
#+END_SRC

ido history:

- [X] ido-toggle-prefix (C-p) > C-o (open-line)
- [X] previous-history-element > C-p

#+BEGIN_SRC emacs-lisp
(defun remap-ido-toggle-prefix ()
  (let ((map ido-common-completion-map))
    (define-key map [(control ?o)] 'ido-toggle-prefix)
    (define-key map [(control ?p)] 'previous-history-element)))

(add-hook 'ido-setup-hook 'remap-ido-toggle-prefix)
#+END_SRC

*** DONE Symbol completion                                          :binding:

- [X] ~dabbrev-expand~ (~M-/~) > ~M-ç~
- [X] ~dabbrev-completion~ (~C-M-/~) > ~M-Ç~
- [ ] ~completion-at-point~ (~C-M-i~, ~M-TAB~) > ~M-ñ~
- [X] use ~TAB~ for completion in addition to identation

#+BEGIN_SRC emacs-lisp
(global-set-key [(meta ?ç)] 'dabbrev-expand)
(global-set-key [(meta ?Ç)] 'dabbrev-completion)
;; (global-set-key [(meta ?ñ)] 'completion-at-point)

(setq tab-always-indent 'complete)

;; these functions can be used in hooks

(defun set-tab-indent-complete ()
  "Set `tab-always-indent' to `complete' in the current buffer."
  (setq-local tab-always-indent 'complete))

(defun set-tab-always-indent ()
  "Set `tab-always-indent' to t in the current buffer."
  (setq-local tab-always-indent t))
#+END_SRC

** DONE Dired                                                       :binding:

- [X] add support for alternate set of listing switches
- [X] ~dired-toggle-listing-switches~ > ~{~
- [X] ~dired-refresh-buffer~ > ~f5~

#+BEGIN_SRC emacs-lisp
(require 'dired)

(define-key dired-mode-map [?{] 'dired-toggle-listing-switches)
(define-key dired-mode-map [f5] 'dired-refresh-buffer)

(setq dired-listing-switches "-hl")
(setq dired-listing-switches-alt "-hla")

(defcustom dired-listing-switches-alt "-l"
  "Alternate set of switches passed to `ls' for Dired.  Use
  `dired-toggle-listing-switches' to toggle between these switches
  and the normal switches in a Dired buffer."
  :type 'string :group 'dired)

(defun dired-toggle-listing-switches ()
  "Toggle between normal listing switches and alternate listing
  switches in Dired buffers.  See `dired-listing-switches' and
  `dired-listing-switches-alt'."
  (interactive)
  (let* ((state (not (get 'dired-toggle-listing-switches
                          'saved-state)))
         (switches (if state
                       dired-listing-switches-alt
                     dired-listing-switches)))
    (put 'dired-toggle-listing-switches 'saved-state state)
    (if (dired-safe-switches-p switches)
        (progn
          (setq dired-actual-switches switches)
          (revert-buffer))
      (error "Unsafe switches: \"%s\"" switches))))

(defun dired-refresh-buffer ()
  "Refresh Dired buffer without prompting for confirmation."
  (interactive)
  (unless (string= major-mode "dired-mode")
    (error "Not a Dired buffer"))
  (revert-buffer nil t)
  (message "Directory listing updated."))
#+END_SRC
** DONE Spelling

- [X] use spell-checker ~hunspell~
- [X] set default dictionary

#+BEGIN_SRC emacs-lisp
;; spelling

(setq ispell-program-name "hunspell")
(ispell-change-dictionary "en_GB" t)    ; default dictionary
#+END_SRC

** DONE Printing

- [X] set settings for PostScript hardcopies

#+BEGIN_SRC emacs-lisp
(setq ps-paper-type 'a4)
(setq ps-print-color-p nil)
(setq ps-print-header nil)
;; possible fonts: Courier, Helvetica, NewCenturySchlbk, Palatino, Times
(setq ps-font-family 'Courier)
(setq ps-font-size 10)
#+END_SRC

** DONE Windows / buffers                                           :binding:

- [X] ~revert-buffer~ > ~f5~
- [ ] ~other-window~ > ~C-TAB~ (~org-force-cycle-archived~)
- [X] ~kill-this-buffer~ > ~C-x k~ (~(ido-)kill-buffer~)

#+BEGIN_SRC emacs-lisp
(global-set-key [f5] 'revert-buffer)
(global-set-key [(control ?x) ?k] 'kill-this-buffer)
;; (global-set-key [(control tab)] 'other-window)
#+END_SRC

** TODO Mouse

- [X] make middle-click paste at point position

#+BEGIN_SRC emacs-lisp
(setq mouse-yank-at-point t)         ; don't move point when yanking
;; (setq select-active-regions 'only)
#+END_SRC

** TODO Clipboard

#+BEGIN_SRC emacs-lisp
;; (setq select-enable-primary nil)
;; (setq select-enable-clipboard t)
#+END_SRC

** TODO General editing

*** DONE Motion                                                     :binding:

- [X] double space marks end of sentence
- [X] ~backward-paragraph~ > ~M-p~
- [X] ~forward-paragraph~ > ~M-n~

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space t)
(global-set-key [(meta ?n)] 'forward-paragraph)
(global-set-key [(meta ?p)] 'backward-paragraph)
#+END_SRC

*** TODO Mark and region

#+BEGIN_SRC emacs-lisp
;; (transient-mark-mode 1)
#+END_SRC

*** TODO Formatting paragraphs

- [X] set default value for ~fill-column~
- [ ] ~unfill-paragraph~

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 70)

;; (defun unfill-paragraph ()
;;   "Takes a multi-line paragraph and makes it into a single line."
;;   (interactive)
;;   (let ((fill-column (point-max)))
;;     (fill-paragraph nil t)))
#+END_SRC

*** TODO Comments

- [ ] ~copy-and-comment~

#+BEGIN_SRC emacs-lisp
;; (defun copy-and-comment (beg end)
;;   "Insert a copy of the region and comment the original out."
;;   (interactive "r")
;;   (let ((p (copy-marker end)))
;;     (kill-ring-save beg end)
;;     (comment-region beg end)
;;     (goto-char p)
;;     (yank)
;;     (goto-char p)))
#+END_SRC

*** TODO Line operations

- [ ] ~copy-line~
- [ ] ~duplicate-line~

#+BEGIN_SRC emacs-lisp
;; (defun copy-line (arg)
;;   "Copy lines (as many as prefix argument) in the kill ring"
;;   (interactive "p")
;;   (kill-ring-save (line-beginning-position)
;;                (line-beginning-position (+ 1 arg)))
;;   (message "%d line%s copied" arg (if (= 1 arg) "" "s")))

;; ;; http://stackoverflow.com/questions/88399/
;; (defun duplicate-line (arg)
;;   "Duplicate current line, leaving point in lower line."
;;   (interactive "*p")
;;   (setq buffer-undo-list (cons (point) buffer-undo-list))
;;   (let ((bol (save-excursion (beginning-of-line) (point))) eol)
;;     (save-excursion
;;       (end-of-line)
;;       (setq eol (point))
;;       (let ((line (buffer-substring bol eol))
;;          (buffer-undo-list t)
;;          (count arg))
;;      (while (> count 0)
;;        (newline)         ;; because there is no newline in 'line'
;;        (insert line)
;;        (setq count (1- count))))
;;       (setq buffer-undo-list (cons (cons eol (point)) buffer-undo-list))))
;;   (next-line arg))

;; (global-set-key (kbd "C-c w")   'copy-line)
;; (global-set-key (kbd "C-c d")   'duplicate-line)
#+END_SRC

*** DONE Killing                                                    :binding:

- [ ] ~kill-line~ at start of line kills whole line
- [X] ~kill-whole-line~ (~C-S-backspace~) >
                                 ~C-x C-d~ (~ido-list-directory~)
- [X] ~delete-indentation~ (~M-^~) > ~M-+~
- [X] ~delete-horizontal-space~ (~M-\~) > ~M-¡~
- [X] ~delete-blank-lines~ (~C-x C-o~) > ~M-¿~

#+BEGIN_SRC emacs-lisp
;; (setq kill-whole-line t)

(global-set-key [(control ?x) (control ?d)] 'kill-whole-line)
(global-set-key [(meta ?+)] 'delete-indentation)
(global-set-key [(meta ?¡)] 'delete-horizontal-space)
(global-set-key [(meta ?¿)] 'delete-blank-lines)
#+END_SRC

** DONE Mail

*** DONE General settings

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Ernest Adrogué")
(setq user-mail-address "nr9@posteo.de")
(setq mail-from-style 'parens)
#+END_SRC

*** DONE Outgoing mail

#+BEGIN_SRC emacs-lisp
(require 'smtpmail)
(setq send-mail-function 'smtpmail-send-it)
(setq message-send-mail-function 'message-smtpmail-send-it)
(setq smtpmail-default-smtp-server "posteo.de")
(setq smtpmail-smtp-server "posteo.de")
(setq smtpmail-smtp-service 465)
(setq smtpmail-stream-type 'ssl)
#+END_SRC

** DONE Indentation

- [X] indent with spaces

#+BEGIN_SRC emacs-lisp
(defun indent-style-tabs ()
  "Set the buffer-local variable `indent-tabs-mode' to t."
  (interactive)
  (setq indent-tabs-mode t))

(defun indent-style-spaces ()
  "Set the buffer-local variable `indent-tabs-mode' to nil."
  (interactive)
  (setq indent-tabs-mode nil))

(setq-default indent-tabs-mode nil)
#+END_SRC

** TODO Modes
*** DONE Default major modes

- [X] set text mode as default mode
- [X] plain text files (~*.te?xt~) use use org mode
- [X] compose mail with message mode

#+BEGIN_SRC emacs-lisp
(setq-default major-mode 'text-mode)

(add-to-list 'auto-mode-alist '("\\.te?xt\\'" . org-mode))

(add-to-list 'magic-mode-alist '("From:" . message-mode))
#+END_SRC

*** DONE Text mode

- [X] enable auto-filling

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

*** DONE PO mode                                                    :binding:
- [X] turn on ruler mode in subedit buffers
- [X] add spell-checking support (~po-ispell-msgstr~ > ~i~)
- [X] add support for file-local variables in the subedit buffer using
  proxy variables ~po-fill-colum~, ~po-goal-column~,
  ~po-tab-stop-list~ and ~po-ispell-skip-region-alist~.

#+BEGIN_SRC emacs-lisp
(defvar-local po-fill-column fill-column
  "Value of `fill-column' in subedit buffers.")

(defvar-local po-goal-column goal-column
  "Value of `goal-column' in subedit buffers.")

(defvar-local po-tab-stop-list tab-stop-list
  "Value of `tab-stop-list' in subedit buffers.")

(defvar-local po-language nil
  "Language code of the current buffer.

  An appropriate dictionary for checking spelling errors in message
  strings is chosen according to the value of this variable.

  Changing the value of this variable has no immediate effect.  To
  change the spell-checking dictionary for this buffer, use M-x
  `po-change-dictionary' instead.")

(defvar-local po-ispell-dictionary nil
  "Ispell dictionary to use in subedit buffers.")

(defvar po-ispell-dictionary-alist nil
  "A list of the form ((LANG . DICT) ...) mapping language codes
  to dictionary names.")

(defvar-local po-enable-ruler-mode nil
  "Whether to enable `ruler-mode' in subedit buffers.")

;; must not be nil due to a bug
(defvar po-ispell-skip-region-alist nil
  "Value of `ispell-skip-region-alist' in subedit buffers.")

;; format string placeholders
(add-to-list 'po-ispell-skip-region-alist
             '("%\\([0-9]+$\\)?\\([-+ 0#]\\)?\\([0-9]+|\\*\\)?\\(\\.\\(?:[0-9]\\|\\*\\)\\)?\\([hlLzht]\\|hh\\|ll\\)?[%diufFeEgGxXoscpAn]"))

;; skip leading/trailing/standalone dashes and command switches
(add-to-list 'po-ispell-skip-region-alist
             '("\\(\\W\\|\\`\\)[-+]\\(\\W\\|[[:alnum:]]+\\|\\'\\)"))

;; skip apostrophes at word boundaries
;; (add-to-list 'po-ispell-skip-region-alist '("\\(\\W\\|\\`\\)[']"))
;; (add-to-list 'po-ispell-skip-region-alist '("[']\\(\\W\\|\\'\\)"))

(make-variable-buffer-local 'po-ispell-skip-region-alist)

(put 'po-fill-column 'safe-local-variable 'integerp)
(put 'po-goal-column 'safe-local-variable 'integerp)
(put 'po-tab-stop-list 'safe-local-variable 'listp)
(put 'po-language 'safe-local-variable 'stringp)
(put 'po-enable-ruler-mode 'safe-local-variable 'booleanp)

(setq po-auto-edit-with-msgid t)
(setq-default po-enable-ruler-mode t)
(setq po-ispell-dictionary-alist '(("ca" . "ca_ES")))


(defvar po-entry-type)

(defun po-ispell-msgstr ()
  "Check message string for spelling errors."
  (interactive)
  (let ((buffer (concat "*" (buffer-name) "*"))
        po-ispell-user-interacted)
    (po-find-span-of-entry)
    (if (eq po-entry-type 'untranslated)
        (message "Ignoring untranslated entry.")
      (save-window-excursion (po-edit-msgstr))
      (when (get-buffer buffer)
        (set-buffer buffer)
        (add-hook 'ispell-update-post-hook
                  `(lambda ()
                     (pop-to-buffer ,buffer)
                     (setq po-ispell-user-interacted t))
                  t t)
        (ispell-buffer)
        (if po-ispell-user-interacted
            (progn
              (pop-to-buffer buffer)
              (message po-subedit-message))
          (po-subedit-abort))))))

(with-eval-after-load 'po-mode
  (define-key po-mode-map [?i] 'po-ispell-msgstr))

(defun po-change-dictionary (&optional dict)
  "Change spell-checking dictionary."
  (interactive
   (list (completing-read
          "Use dictionary (RET for current, SPC to complete): "
          (and (fboundp 'ispell-valid-dictionary-list)
               (mapcar 'list (ispell-valid-dictionary-list)))
          nil t)))
  (setq po-ispell-dictionary dict))

(defun po-set-dictionary (&optional force)
  "Set `po-ispell-dictionary' according to the value of
  `po-language'; guess the target language if `po-language' is
  nil."
  (when (or (not po-ispell-dictionary) force)
    (let* ((lang (or po-language (po-guess-language)))
           (dict (when (boundp 'po-ispell-dictionary-alist)
                   (cdr (assoc lang po-ispell-dictionary-alist)))))
      (cond ((not lang)
             (message "could not guess language"))
            ((not dict)
             (message "no known dictionaries for language \"%s\"" lang)))
      (unless dict
        (setq dict ispell-local-dictionary))
      (setq po-ispell-dictionary dict))))

(add-hook 'po-mode-hook 'po-set-dictionary)

(defun po-guess-language ()
  "Guess the target language of the current PO file."
  (save-excursion
    (save-restriction
      (widen)
      (goto-char (point-min))
      (unless (re-search-forward
               po-any-msgstr-block-regexp nil t)
        (error "no entries found"))
      (goto-char (match-beginning 0))
      (save-window-excursion
        (po-edit-msgstr)
        (let ((lang
               (when (re-search-forward
                      "^Language:[[:blank:]]+\\([[:alnum:]]+\\)<?$"
                      nil t)
                 (po-match-string 1))))
          (po-subedit-abort)
          lang)))))

(defun po-set-subedit-buffer-variables ()
  "Set variables according to the buffer-local value of the
  corresponding po-* variable in the main buffer."
  (let ((buffer (get-buffer (substring (buffer-name) 1 -1))))
    (when buffer
      (make-local-variable 'ispell-skip-region-alist)
      (dolist (elt '((po-fill-column . fill-column)
                     (po-goal-column . goal-column)
                     (po-tab-stop-list . tab-stop-list)
                     (po-ispell-skip-region-alist . ispell-skip-region-alist)
                     (po-ispell-dictionary . ispell-local-dictionary)))
        (set (cdr elt) (buffer-local-value (car elt) buffer))))))

(add-hook 'po-subedit-mode-hook 'po-set-subedit-buffer-variables)

(defun po-enable-ruler-mode-maybe ()
  "Enable `ruler-mode' if `po-enable-ruler-mode' is non-nil."
  (when po-enable-ruler-mode (ruler-mode)))

(add-hook 'po-subedit-mode-hook 'po-enable-ruler-mode-maybe)
#+END_SRC

*** DONE AUCTeX

- [X] use XeTeX by default
- [X] set default document class options
- [X] configure default labels
- [X] disable syntactic comments except in docTeX mode
- [X] normal ~RET~ key
- [X] alternative (simpler) syntax highlighting scheme
- [X] normal font height in scripts and section titles
- [ ] add support for ~completion-at-point~
- [X] open PDF output with ~xdg-open~
- [X] extend list of environments to be folded
- [X] enable RefTeX minor mode in LaTeX mode
- [X] enable LaTeX fold minor mode in LaTeX mode
- [X] enable LaTex math minor mode in LaTeX mode

#+BEGIN_SRC emacs-lisp
(setq TeX-engine 'xetex)

(setq LaTeX-default-options "a4paper")

(setq LaTeX-section-label nil)

(defvar LaTeX-label-alist)

(with-eval-after-load 'latex
  (dolist (elt '(("multline"     . LaTeX-equation-label)
                 ("subequations" . LaTeX-equation-label)))
    (add-to-list 'LaTeX-label-alist elt)))

(setq LaTeX-syntactic-comments nil)
(add-hook 'docTeX-mode-hook 'LaTeX-enable-syntactic-comments)

(setq TeX-newline-function 'newline-and-indent)

;; (setq TeX-auto-untabify t)

;; simpler font locking scheme
(setq TeX-install-font-lock 'tex-font-setup)
(setq font-latex-fontify-script nil)
(setq font-latex-fontify-sectioning 'color)

;; (setq TeX-auto-save t)
;; (setq TeX-parse-self t)

;; ;; support symbol completion using standard completion mechanism
;; (defun TeX-set-completion-at-point-functions ()
;;   (setq-local completion-at-point-functions '(TeX-complete-symbol)))

;; (add-hook 'TeX-mode-hook 'TeX-set-completion-at-point-functions)

(add-hook 'TeX-mode-hook 'set-tab-always-indent)

(defvar TeX-view-program-selection)

(with-eval-after-load 'tex
  (add-to-list 'TeX-view-program-selection '(output-pdf "xdg-open")))

(defvar TeX-fold-env-spec-list)         ; compiler warning

(with-eval-after-load 'tex-fold
  (dolist (elt '("displaymath"
                 "equation"
                 "equation*"
                 "eqnarray"
                 "eqnarray*"
                 "subequations"
                 "gather"
                 "gather*"
                 "align"
                 "align*"
                 "alignat"
                 "alignat*"
                 "flalign"
                 "flalign*"
                 "multline"
                 "multline*"
                 "figure"
                 "table"
                 "thebibliography"
                 "titlepage"))
    (add-to-list 'TeX-fold-env-spec-list
                 `(,(format "[%s]" elt) (,elt)))))

(add-hook 'LaTeX-mode-hook 'reftex-mode)
(add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
(add-hook 'LaTeX-mode-hook 'TeX-fold-mode)

(defun LaTeX-enable-syntactic-comments ()
  "Set `LaTeX-enable-syntactic-comments' to t in the current buffer."
  (setq-local LaTeX-syntactic-comments t))

;; http://tex.stackexchange.com/questions/124246/
;; (setq LaTeX-command-style
;;       '(("" "%(PDF)%(latex) -file-line-error %S%(PDFout)")))
#+END_SRC

*** DONE Org                                                        :binding:

Default locations of org files and other files used by org-mode.

#+BEGIN_SRC emacs-lisp
(setq org-directory (expand-file-name "~/doc/org"))
(setq org-default-notes-file "todo.org")
(setq org-agenda-files (expand-file-name "agenda-files" org-directory))
(setq org-archive-location "%s-archive::")
#+END_SRC

Put capture and structure templates in a separate file; or set this to
nil to use the customize interface instead.

#+BEGIN_SRC emacs-lisp
(defvar org-templates-file nil
  "Path to a file with template definitions for org-mode.
The file will be loaded by init.el with `load-file', unless the
value of this variable is `nil'.")

(setq org-templates-file
      (expand-file-name "org-templates.el" user-emacs-directory))
#+END_SRC

Startup settings.

#+BEGIN_SRC emacs-lisp
(setq org-startup-folded t)
(setq org-startup-truncated t)
#+END_SRC

Turn off all indentation virtual or real.

#+BEGIN_SRC emacs-lisp
(setq org-startup-indented nil)
(setq org-adapt-indentation nil)
#+END_SRC

Lessen visual clutter.  Restart =font-lock-mode= if you change these.

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
(setq org-hide-leading-stars t)
#+END_SRC

Settings for inserting new headings or items.  Must experiment to find
optimal values.

#+BEGIN_SRC emacs-lisp
;; (setq org-M-RET-may-split-line t)
;; (setq org-insert-heading-respect-content t)
#+END_SRC

Place footnotes at the end of the current section.

#+BEGIN_SRC emacs-lisp
(setq org-footnote-section nil)
#+END_SRC

Don't mess about with the indentation of source code blocks.

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)
#+END_SRC

Allow evaluation of Emacs Lisp and Unix shell blocks.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'org
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell      . t))))
#+END_SRC

Log change to "done" state and enforce todo states dependencies.

#+BEGIN_SRC emacs-lisp
(setq org-enforce-todo-dependencies t)
(setq org-enforce-todo-checkbox-dependencies t)
(setq org-log-done 'time)
#+END_SRC

Load templates.

#+BEGIN_SRC emacs-lisp
(when (and org-templates-file
           (file-exists-p org-templates-file))
  (load-file org-templates-file))
#+END_SRC

Set global capture key.

#+BEGIN_SRC emacs-lisp
(global-set-key [(control ?c) ?c] 'org-capture)
#+END_SRC

General export settings.

#+BEGIN_SRC emacs-lisp
(setq org-export-with-author nil)
(setq org-export-with-creator nil)
(setq org-export-with-date nil)
(setq org-export-with-email nil)
(setq org-export-with-toc nil)
#+END_SRC

Disable C-TAB?

#+BEGIN_SRC emacs-lisp
;; (defvar org-mode-map)                 ; prevent compiler warning

;; (defun org-disable-control-tab ()
;;   (define-key org-mode-map [(control tab)] nil))

;; (add-hook 'org-mode-hook 'org-disable-control-tab)
#+END_SRC

*** DONE Programming modes

- [X] set ~fill-column~
- [X] show matching parentheses
- [X] show white space
- [X] set file permissions when saving executable scripts

#+BEGIN_SRC emacs-lisp
(setq prog-fill-column 76)

(add-hook 'prog-mode-hook 'prog-set-fill-column)
(add-hook 'prog-mode-hook 'show-paren-mode)
(add-hook 'prog-mode-hook 'whitespace-mode)

(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

(defun prog-set-fill-column ()
  "Set the buffer-local variable `fill-column' according the
  value of `prog-fill-column'"
  (setq fill-column prog-fill-column))

(defvar prog-fill-column fill-column
  "Value of `fill-column' in programming modes.")
#+END_SRC

*** DONE Lisp

- [ ] enable eldoc-mode (enabled globally by default in 25.1)

#+BEGIN_SRC emacs-lisp
;; (add-hook 'lisp-mode-hook 'eldoc-mode)
;; (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
#+END_SRC

*** DONE Slime

- [X] use pre-compiled image for (allegedly) quicker startup

#+BEGIN_SRC emacs-lisp
(defun slime-setup-quick-startup ()
  (let ((slime-core (expand-file-name
                     (concat (file-name-as-directory "slime")
                             "sbcl.core-for-slime")
                     user-emacs-directory)))
    (when (file-exists-p slime-core)
      (add-to-list 'slime-lisp-implementations
                   `(sbcl-quick-startup ("sbcl" "--core" ,slime-core))))))

(with-eval-after-load 'slime (slime-setup-quick-startup))
#+END_SRC

*** DONE Comint                                                     :binding:

- [X] ~comint-previous-matching-input-from-input~ > ~M-p~
- [X] ~comint-next-matching-input-from-input~ > ~M-n~

#+BEGIN_SRC emacs-lisp
;; (defvar comint-mode-map)                 ; prevent compiler warning

(defun comint-set-history-keys ()
  (let ((map comint-mode-map))
    (define-key map [(meta ?p)] 'comint-previous-matching-input-from-input)
    (define-key map [(meta ?n)] 'comint-next-matching-input-from-input)))

(with-eval-after-load 'comint-mode
  (comint-set-history-keys))

#+END_SRC

*** TODO Python

#+BEGIN_SRC emacs-lisp
;; python mode (use the version bundled with emacs)
(when (fboundp 'py-shell) (fmakunbound 'py-shell))
(when (fboundp 'doctest-mode) (fmakunbound 'doctest-mode))
(autoload 'python-mode "python" "Python editing mode (python.el)" t)
#+END_SRC

*** TODO ESS                                                        :binding:

- [X] ~comint-previous-matching-input-from-input~ > ~M-p~
- [X] ~comint-next-matching-input-from-input~ > ~M-n~

#+BEGIN_SRC emacs-lisp
;; ess overrides comint-mode-map

(defvar inferior-ess-mode-map)          ; compiler warning

(defun ess-set-history-keys ()
  (let ((map inferior-ess-mode-map))
    (define-key map [(meta ?p)] 'comint-previous-matching-input-from-input)
    (define-key map [(meta ?n)] 'comint-next-matching-input-from-input)))

(with-eval-after-load 'ess
  (ess-set-history-keys))

;; try to not (require 'ess-site) as it slows down start-up
(autoload 'R-mode "ess-site.el" "Major mode for editing R source." t)
(autoload 'Rd-mode "ess-rd" "Major mode for editing R documentation." t)
(add-to-list 'auto-mode-alist '("\\.[rR]\\'" . R-mode))
(add-to-list 'auto-mode-alist '("\\.[Rr]out" . R-transcript-mode))
(add-to-list 'auto-mode-alist '("\\.Rd\\'" . Rd-mode))
(add-to-list 'interpreter-mode-alist '("Rscript" . R-mode))
(add-to-list 'interpreter-mode-alist '("r" . R-mode))

;; enable hide-show to allow roxygen comments be un/folded with <TAB>
(setq ess-roxy-hide-show-p t)

;; intepreter options
(setq inferior-R-args "--no-save --quiet")
#+END_SRC

* Notes

** DONE Key sequence formats
See section "Key Sequences" in Emacs Lisp Reference manual.  Vector format
is to be preferred.

*** String format
- Control and Meta character events: ~\C-~ ~\M-~
- ~TAB~, ~RET~, ~ESC~, ~DEL~ evencts: ~\t~ ~\r~ ~\e~ ~\d~
- Alphanumeric characters: ~a~ ~b~ ...

Example: ~"\C-xl"~

Sequences with non-ASCII characters or function keys cannot be represented
as strings.

*** Vector format
Key sequences represented as ~[event1 event2 ...]~ where ~eventN~ is
an event in Lisp form:

- Single characters: ~?a~ ~?b~ ~?c~ ...
- Event modifiers (escape format): ~\C-~ ~\M-~
- Event modifiers (in lists): ~meta~ ~control~ ~shift~ ~hyper~ ~super~
  ~alt~
- Function keys: ~backspace~ ~tab~ ~newline~ ~return~ ~delete~ ~left~
  ~up~ ~right~ ~down~ ~f1~ ~f2~ ~f3~ ...

Examples: ~[(control ?x) ?l]~ (same as ~[?\C-x ?l]~), ~[backspace]~,
~[(hyper left)]~ ...

** TODO Unbound keys
Unbound keys in ES layout:
- ~M-+~
- ~M-¡~
- ~M-S-¡~
- ~M-S-'~
- ~M-ñ~
- ~M-S-ñ~
- ~M-ç~
- ~M-S-ç~
- ~M-S-<a-z>~

* Footer

#+BEGIN_SRC emacs-lisp
;; Local Variables:
;; eval: (defun write-init-file-and-compile ()
;;         (and (y-or-n-p "Write source and byte-compile? ")
;;              (org-babel-tangle)
;;              (byte-compile-file
;;               (replace-regexp-in-string
;;                "\\.org\\'" ".el" (buffer-file-name)))))
;; eval: (add-hook 'after-save-hook 'write-init-file-and-compile nil t)
;; End:
#+END_SRC
